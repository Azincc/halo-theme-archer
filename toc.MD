# Hexo Theme Archer 目录（TOC）生成逻辑研究

## 1. Hexo 版本的目录生成流程

1. **Markdown 渲染阶段**  
   Hexo 在编译 Markdown 时会为正文生成带有 `id` 的标题标签，渲染结果存放在 `page.content`（HTML 字符串）。

2. **模板阶段调用 Hexo 内置 `toc` helper**  
   在 `layout/layout.ejs` 中，主题使用 Hexo 提供的 `toc()` 帮助函数，把 `page.content` 解析成一棵目录树，并输出带有 `.toc`、`.toc-item` 等 class 的 HTML 结构：

   ```ejs
   <%_ if(is_post() && (page.toc || (theme.toc && page.toc !== false))) { _%>
     <div class="toc-wrapper toc-wrapper-loding" style=<%- partial('_partial/intro-height', {attr: 'top'}) %>>
       <div class="toc-catalog">
         <span class="iconfont-archer catalog-icon">&#xe613;</span><span>CATALOG</span>
       </div>
       <%- toc(page.content, {class: 'toc', list_number: true}) %>
     </div>
   <%_ } _%>
   ```

   `toc()` 会直接输出类似下列结构：

   ```html
   <ol class="toc">
     <li class="toc-item toc-level-2"><a class="toc-link" href="#section">
       <span class="toc-text">Section</span>
     </a></li>
     ...
   </ol>
   ```

3. **前端脚本初始化交互**  
   `src/js/init.js` 在 `DOMContentLoaded` 之后调用 `toc()`（即 `src/js/toc.js`）：

   ```js
   const $toc = $('.toc')
   const $article = $('article.article-entry')
   ```

   由于模板已经输出 `.toc` 节点，jQuery 能够正常获取目录 DOM，脚本再根据滚动位置折叠/展开目录、同步高亮状态。

## 2. Halo 迁移版本的现状

* **模板未生成 `.toc` 容器**  
  在 Halo 主题的 `templates/modules/layout.html` 中，与 Hexo 对应位置被替换为注释：

  ```html
  <!-- TOC (Table of Contents) is typically generated by JavaScript or disabled in Halo 2.x -->
  <!-- The content.toc field does not exist in ContentVo structure -->
  <!-- If TOC is needed, implement it using JavaScript parsing of article headings -->
  ```

  `post.html` 只输出正文：

  ```html
  <article class="article-entry" th:utext="${post.content.content}"></article>
  ```

  Halo 的 `ContentVo` 并不包含 Hexo 那样的 TOC 数据结构，也没有可用的 `toc()` helper，因此最终页面中根本不会出现 `.toc` 元素。

* **前端查询选择器失效**  
  迁移后的 `templates/assets/scripts/toc.js` 里仍然保留了 Hexo 时代的写法：

  ```js
  const $toc = $('.toc')
  const $article = $('post.content.content')
  ```

  第一行因为页面上没有 `.toc` 元素，返回的是一个空 jQuery 对象。第二行在迁移时也出现了误替换（缺少 `.` 和标签名，本应是 `$('article.article-entry')`），导致 `$article` 同样为空。

  后续代码多次访问 `$toc[0]`、`$article.find('h1, h2, ...')`，在 Halo 页面中会触发 `undefined` 访问或直接跳过逻辑。

* **平台差异**  
  - Hexo：静态站点构建阶段即可拿到完整 HTML，`toc()` helper 能直接解析字符串生成目录。  
  - Halo：运行时通过 API 返回 `ContentVo`，只有纯正文 HTML，没有额外的 TOC 字段。若要呈现目录，需要自行解析文章中的标题节点并动态插入 DOM。

## 3. `const $toc = $('.toc')` 在 Halo 中获取不到元素的原因

1. **模板层：** Halo 版本没有输出 `<ol class="toc">` 结构，`.toc` 根节点不存在。  
2. **数据层：** Halo 的 `post.content` 不包含预生成的 TOC 数据，也没有 Hexo `toc()` 等价方法可用。  
3. **脚本层：** 迁移时误将 `$('article.article-entry')` 写成了 `$('post.content.content')`，进一步导致标题选择失败。

综合上述，Halo 页面加载完成后 DOM 中不存在 `.toc`，因此 `const $toc = $('.toc')` 得到的只是一个空集合，后续逻辑无法生效。

## 4. 后续实现建议

1. **重新输出 TOC 容器：** 在 `modules/layout.html` 中重新加入 `toc-wrapper`、`ol.toc` 的占位容器，保证脚本有挂载点。  
2. **修正脚本选择器：** 将 `$article` 的选择器改为 `$('article.article-entry')`，并在访问 `$toc[0]` 前增加空值校验。  
3. **客户端生成目录：** 在没有 `toc()` helper 的情况下，可在 `toc.js` 中解析 `$article` 内的标题节点（`querySelectorAll('h1~h6')`），手工构造目录树并插入 `.toc` 容器。这样可以在 Halo 环境下复刻 Hexo 的行为。  
4. **可选方案：** 如果 Halo 未来提供类似 `post.toc` 字段或插件化方案，可直接利用官方能力恢复服务器端生成的目录。

## 5. 结论

Hexo 主题依靠构建期的 `toc()` helper 生成目录 HTML，因而前端脚本能顺利基于 `.toc` 节点进行交互；Halo 迁移版缺少这一 helper，也没有对应的模板输出，导致 `.toc` DOM 根本不存在，`const $toc = $('.toc')` 始终获取不到对象。要让目录功能在 Halo 中生效，需要补足 DOM 挂载点并改写脚本，以在运行时解析正文标题并动态生成目录。